=====================
Running a Simulation
=====================

Once you've built a model specification that describes the plugins, components, and configuration for the model you
want to run, it's time to run the simulation defined by that model specification using ``vivarium``. There are two ways
to run a single simulation. We will describe first the process for running a simulation from the command line.

.. contents::
   :depth: 1
   :local:
   :backlinks: none

Running from the Command Line
------------------------------
To run from the command line, we'll use the :func:`vivarium.interface.cli.simulate` command. This command is actually
a group containing three subcommands: ``run``, ``test``, and ``profile``. We will focus on ``run`` here. We'll start
by covering how to use this command to run a simulation from a model specification and then cover at a high-level what
happens when your model is running.


How to Use ``simulate run``
+++++++++++++++++++++++++++
The basic use of ``simulate run`` requires no more than a model specification yaml file. With this, you can do the
following to run the model defined by that specification:

.. code-block:: console

    simulate run /path/to/your/model/specification

By default, ``simulate run`` will use ~/vivarium_results as the results directory. If you navigate to that directory,
you should see a subdirectory with the name of your model specification has been created, within which is another
subdirectory named for the start time of the run. In here, you should see two hdf files: final_state.hdf, which is the
population state table at the end of the simulation, and output.hdf, which is the results of the metrics generated by
the simulation.

``simulate run`` also provides various flags which you can use to configure options for the run. These are:

.. list-table:: **Available** ``simulate run`` **options**
    :header-rows: 1
    :widths: 30, 40

    *   - Option
        - Description
    *   - | **--results-directory** or **-o**
        - | The top-level directory in which to write results.
          | Within this directory, a subdirectory named to match the
          | model-specification file will be created. Within this, a further
          | subdirectory named for the time at which the run was started will
          | be created.
    *   - | **--verbose** or **-v**
        - | Report each time step as it occurs during the run.
    *   - | **--log**
        - | A path at which a log file should be created.
    *   - | **--pdb** or **with_debugger**
        - | If an error occurs, drop into the python debugger.


Let's illustrate how to use them. Say we run the following:

.. code-block:: console

    simulate run /path/to/your/model/specification -o /path/to/output/directory --log /path/to/log/file --pdb -v

Let's walk through how each of these flags will change the behavior from our initial plain ``simulate run``. First, we
have specified an output directory via the **-o** flag. In our first example, outputs went to ~/vivarium_results. Now
they will go to our specified directory. Second, we have also provided a path to a log file via **--log** at which we
can find the log outputs of our simulation run. Next, we have provided the **--pdb** flag so that if something goes
wrong in our run, we will drop into the python debugger where we can investigate. Finally, we have turned on the verbose
option via the **-v** flag. Whereas before, we saw nothing printed to the console while our simulation was running, we
will now see something like the following:

::

    DEBUG:vivarium.framework.values:Registering PopulationManager.metrics as modifier to metrics
    DEBUG:vivarium.framework.values:Registering value pipeline mortality_rate
    DEBUG:vivarium.framework.values:Registering value pipeline metrics
    DEBUG:vivarium.framework.values:Unsourced pipelines: []
    DEBUG:vivarium.framework.engine:2005-07-01 00:00:00
    DEBUG:vivarium.framework.engine:2005-07-04 00:00:00
    DEBUG:vivarium.framework.engine:2005-07-07 00:00:00
    DEBUG:vivarium.framework.engine:2005-07-10 00:00:00
    DEBUG:vivarium.framework.engine:2005-07-13 00:00:00
    DEBUG:vivarium.framework.engine:{'simulation_run_time': 0.7717499732971191,
     'total_population': 10000,
     'total_population_tracked': 10000,
     'total_population_untracked': 0}
    DEBUG:vivarium.framework.engine:Some configuration keys not used during run: {'input_data.cache_data', 'output_data.results_directory', 'input_data.intermediary_data_cache_path'}

The specifics of these messages will depend on your model specification, but you should see a series of timestamps that
correspond to the time steps the simulation takes as it runs your model.


What Happens When We ``simulate run``
+++++++++++++++++++++++++++++++++++++
Now that we've seen how to use ``simulate run`` to run a simulation defined by a given model specification yaml file,
let's talk through what happens during that run.

There are **five** stages to the simulation life cycle in ``vivarium``. We will go through each of them as they appear
from the entry point of ``simulate run``.

1. Initialization
    First, ``vivarium`` will set up the results directory as described above, creating the necessary subdirectories. Then,
    the core framework of ``vivarium`` takes over. It parses your model specification, setting up a PluginManager with the
    plugins provided; creating a list of the provided components; and creating a :class:`vivarium.engine.SimulationContext`
    to manage the running of the simulation. At this point, your model specification has been fully parsed and all
    managers and top-level components have been initialized.

2. Setup
    In this stage, the framework moves to setting up the components. For each top level component, the framework applies
    any defaults of the component. Next, it calls ``setup`` on each component. At this stage, components may spawn
    additional components, so this process continues until all components are setup. Setting up components may involve
    loading data, registering or getting pipelines, creating lookup tables, registering population initializers, getting
    randomness streams, etc. The specifics of this are determined by the :func:`setup` method on each component - the
    framework itself simply calls that method.

3. Initialization of the Base Population
    It's not until this stage that the framework actually generates the base population for the simulation. Here, the
    framework rewinds the simulation clock one time step and generates the population with ages smeared between the
    simulation start time and that start time minus one time step. Note that this rewinding of the clock is purely what
    it sounds like - there is no concept of a time step being taken here. Instead, the clock is literally reset back the
    duration of one time step. Once the simulant population is generated, the clock is reset to the simulation start
    time, again by changing the clock time only without any time step being taken.

4. Event Loop
    At this stage, all the preparation work has been completed and the framework begins to move through the simulation.
    This occurs as an event loop. The framework emits a series of events for each time step: *time_step__prepare*,
    *time_step*, *time_step__cleanup*, *collect_metrics*. By listening for these events, individual components can
    perform actions, including manipulating simulants. In this way does the engine drive the simulation forward.

    .. note::

        Note that we have multiple sources of time during this process. The :class:`vivarium.engine.SimulationContext`
        itself holds onto a clock. This simulation clock is the actual time in the simulation. Events (including e.g.,
        *time_step*) come with a time as well. This time is the time at the start of the next time step, that is, the
        time when any changes made during the loop will happen.

5. Finalization
    The final stage in the simulation life cycle is fittingly enough, finalization. At this stage, the *simulation_end*
    event is emitted to signal that the event loop has finished and the state table is final. At this point, outputs
    should be computed.

These five stages together make up the life cycle of a ``vivarium`` simulation. ``simulate run`` provides your entry
into this life cycle. Supply a model specification to ``simulate run`` and the simulation engine will use it to define
the simulation that progresses through each of these stages.